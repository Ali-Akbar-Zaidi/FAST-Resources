<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<TITLE>Untitled</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.04z">
</HEAD>
<BODY>
<P>
<A NAME="_Toc403834014"><B><FONT SIZE=5>Appendix</FONT></B></A>
<P>
<A NAME="_Toc403834015"><B><FONT SIZE=6>Details of Server&#173;Side
Includes</FONT></B></A>
<UL>
<LI>Understanding what server&#173;side includes are
<LI>What SSI directives are available
<LI>How to turn on server&#173;side includes
<LI>Using variables in server&#173;side include directives
<LI>Recognizing SSI problems when they occur
<LI>Using server&#173;side includes to customize documents when
they're sent<BR>
</UL>
<P>
One of the most powerful things your Apache Web server can do
for you is to tailor the contents of documents before sending
them along to the requesting client. One of the ways you can do
this, the one that's described in this Appendix, is through the
use of <I>Server&#173;Side Includes</I> (SSIs).
<P>
Server&#173;side includes are described to some extent in Chapter
12, but it doesn't go into much detail about how to use them or
what you could do with them. This appendix attempts to fill in
the gaps &#173; so get out your pick and shovel!
<H1><A NAME="_Toc403834016">SSIs &#173; Before You Start</A></H1>
<P>
SSIs are a really cool feature, but like most cool things there's
a cost to using them. The more you use them, the greater the cost
you're going to incur &#173; there ain't no such thing as a free
lunch.
<P>
<I><B>Remember: </B></I>The server handles server&#173;side includes
by carefully scrutinizing the HTML in file question and performing
additional processing when it finds SSI instructions (called &quot;parsing&quot;
the file).
<P>
Whether you're willing to pay the cost or not is up to you:
<UL>
<LI>Since the server is not just throwing the files &quot;over
the wall&quot; to the client, but is examining them first, there's
a cost in terms of response time and CPU time.
<LI>Because of the flexibility of SSIs, using them incautiously
can open up potential security liabilities on your Web server
system &#173; the cost here involves the integrity and security
of your Web host (and potentially any others to which it has access)
</UL>
<P>
If you have a moderately big machine, the actual impact may be
negligible, and you may want to extend the functionality of SSI
parsing to <I>all</I> of your HTML documents. On a less powerful
system, however, you might prefer to either not use them at all,
or to tell the server it should only spend time parsing files
with a particular extension. See the next section for details.
<H1><A NAME="_Toc403834017">When SSIs Go Bad</A></H1>
<P>
While you're becoming familiar with using server&#173;side includes,
you should also become familiar with the following error message:
<PRE>
<FONT SIZE=2>[an error occurred processing this directive]</FONT>
</PRE>
<P>
Ordinarily, the Apache Web server replaces the SSI directive either
with nothing (essentially removing it from the file before sending
it to the client) or with any output it generates. If the server
has a problem of any sort dealing with a directive, though, it
replaces it with this text.
<P>
When you see this message, generic as it is, you should treat
it as a signal to go look at the error log &#173; because that's
where the server puts the <I>real</I> error message describing
what it couldn't do.
<H1><A NAME="_Toc403834018">Enabling Server&#173;Side Includes</A>
</H1>
<P>
In order for the Apache Web server to actually parse any files
looking for server&#173;side include directives to process, you
have to tell it how to proceed.
<UL>
<LI>Your server <I>must</I> have the <CODE>mod_include</CODE>
module built into it &#173; without that, no parsing is going
to happen at all under any circumstances.
<LI>You need to tell the server how to recognize that a file should
be parsed by explicitly naming a file suffix or extension as meaning
&quot;parse any file with this ending.&quot;
<LI>You must enable the appropriate overrides (see Chapter 4)
and options for the scope in which the documents are found.
</UL>
<P>
The first part is easy &#173; <CODE>mod_include</CODE> is usually
part of your average Apache server image. If it isn't, you'll
need to obtain another server image, though, or else rebuild it
yourself and include the module in the <CODE>Configuration</CODE>
file (see Chapter 9).
<P>
The second part is relatively simple, too &#173; just pick one
or more file extensions, such as &quot;<CODE>.shtml</CODE>&quot;
or &quot;<CODE>.htp</CODE>&quot;, and include sections like the
following in your server configuration files:
<PRE>
<FONT SIZE=2>AddType text/html .shtml
AddHandler server&#173;parsed .shtml

</FONT>
</PRE>
<P>
The first line tells the server that any time it processes a file
ending in &quot;<CODE>.shtml</CODE>&quot;, it should tell the
client that it contains HTML. The second line lets it know that
any file with that ending needs to be run through the &quot;<CODE>server&#173;parsed</CODE>&quot;
content handler (which is provided by <CODE>mod_include</CODE>).
<P>
The third part, making sure the scope is covered by the appropriate
overrides and options, is the trickiest portion of all (though
it's still not rocket science). The override that affect server&#173;side
include processing is the <CODE>FileInfo</CODE> override. It doesn't
really affect SSIs directly; rather, it needs to be enabled in
order to use the <CODE>AddType</CODE> and <CODE>AddHandler</CODE>
directives. So you need to have that override in place in the
scope where these directives appear (or at a higher scope, of
course) in order for them to work.
<P>
For example, if you wanted to enable SSIs for all HTML files in
a particular directory, there are a couple of ways you could do
it. One is to declare all the relevant stuff in the server config
files as shown in Figure C&#173;1.
<HR>
<PRE>
<FONT SIZE=2>&lt;Directory /usr/local/web/htdocs/ssi&#173;enabled&gt;
   AddHandler server&#173;parsed .html
   Options Includes
&lt;/Directory&gt;
</FONT>
</PRE>
<HR>

<PRE>
<CENTER><FONT SIZE=1>Figure C&#173;1
</FONT></CENTER>
</PRE>
<P>
<I><B>Tip: </B></I>Did you notice anything unusual about that
container? Like the fact that it didn't include an <CODE>AddType</CODE>
declaration? That's because the server already knows that files
that end in <CODE>.html</CODE> have the media (MIME) type &quot;<CODE>text/html</CODE>&quot;,
so you don't need to tell it again.
<P>
Alternatively, you can put the directives into a <CODE>.htaccess</CODE>
file in the directory where the documents live (or in some ancestor
directory), as shown in Figure C&#173;2.
<HR>
<PRE>
<FONT SIZE=2>AddHandler server&#173;parsed .html
Options Includes
</FONT>
</PRE>
<HR>

<PRE>
<CENTER><FONT SIZE=1>Figure C&#173;2


</FONT></CENTER>
</PRE>
<P>
If you use this second method, the directory in which the documents
(and the <CODE>.htaccess</CODE> file, of course) <I>must</I> be
within the scope of an enabled <CODE>FileInfo</CODE> override
for the <CODE>AddHandler</CODE> directive, and an <CODE>Options</CODE>
override for the <CODE>Options</CODE> directive (funny how that
works out, isn't it?). To show how these work together, take a
look at Figure C&#173;3.
<HR>
<P>
In the server configuration files (<I>e.g.</I>, <CODE>srm.conf</CODE>):
<PRE>
<FONT SIZE=2>&lt;Directory /usr/local/web/htdocs/ssi&#173;enabled&gt; 
    AllowOverride FileInfo Options
&lt;/Directory&gt;

</FONT>
</PRE>
<P>
In the <CODE>/usr/local/web/htdocs/ssi&#173;enabled/.htaccess</CODE>
file:
<PRE>
<FONT SIZE=2>AddHandler server&#173;parsed .html
Options Includes</FONT>
</PRE>
<HR>

<PRE>
<CENTER><FONT SIZE=1>Figure C&#173;3
</FONT></CENTER>
</PRE>
<P>
In this particular arrangement, the server configuration files
just enable the use of the <CODE>AddHandler</CODE> and <CODE>Options</CODE>
directives in the <CODE>.htaccess</CODE> file. One advantage to
doing things this way is that you can change the contents of the
<CODE>.htaccess</CODE> file and have the altered settings take
effect immediately; if they're in the server config files, they
only take effect when you tell the server to reload itself.
<H2><A NAME="_Toc403834019">SSI with all the options</A></H2>
<P>
There are three different levels of functionality that server&#173;side
includes are allowed to perform. These are specified with the
<CODE>Options</CODE> directive, and they're primarily concerned
with security.
<P>
<I><B>Remember: </B></I>Remember that I said (well, wrote) that
security concerns are one of the potential disadvantages of using
server&#173;side includes?
<P>
Like lots of the Apache configuration directives, options and
overrides are scope&#173;oriented. That is, they apply in the
scope where you declare them and all subordinate scopes as well
(such as subdirectories) unless explicitly changed. So if you
include an &quot;<CODE>Options All</CODE>&quot; directive at the
top of your document tree, all subdirectories and sublocations
will inherit the setting.
<P>
You can also selectively turn options on or off by preceding them
with plus or minus symbols. For example:
<PRE>
<FONT SIZE=2>Options +Includes &#173;Indexes
</FONT>
</PRE>
<P>
turns on the <CODE>Includes</CODE> option for the current scope,
and turns off the <CODE>Indexes</CODE> option. This will allow
SSI parsing to occur, but no directory listings, within the current
scope (unless overridden at a lower level, of course).
<P>
<I><B>Technical Stuff:</B></I> This ability to selectively enable
and disable settings currently only applies to the <CODE>Options</CODE>
directive. No others, such as <CODE>AllowOverride</CODE>, permit
this syntax.
<P>
The <CODE>Options</CODE> keywords that relate to server&#173;side
includes are:
<UL>
<LI><CODE>Includes</CODE>
</UL>
<BLOCKQUOTE>
This is the basic option that must be enabled for SSI parsing
to occur at all. If it isn't enabled, even documents that are
marked as eligible for <CODE>server@nbhparsed</CODE> processing
will be passed right through without being examined, and any server&#173;side
include directives in them will be passed to the client as normal
comments.
</BLOCKQUOTE>
<UL>
<LI><CODE>IncludesNoExec</CODE>
</UL>
<BLOCKQUOTE>
If this option is enabled, then documents cannot use the &quot;<CODE>#exec</CODE>&quot;
directive to invoke external system commands or shell scripts.
If they try to, the directive will be replaced in the output sent
to the client with the canonical &quot;SSI oopsie&quot; message:
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>[an error occurred processing this directive]
</FONT>
</PRE>
<UL>
<LI><CODE>ExecCGI</CODE>
</UL>
<BLOCKQUOTE>
The <CODE>ExecCGI</CODE> option explicitly allows the server to
process directives that invoke CGI scripts, even if <CODE>IncludesNoExec</CODE>
is turned on. There are rules that apply to CGI script inclusion
that <I>don't</I> apply to &quot;<CODE>#exec</CODE>&quot; invocations,
so CGIs are considered somewhat safer.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I><B>Warning: </B></I>Be very cautious about enabling external
script invocation, for obvious reasons. I highly recommend that
you include either an &quot;Options None&quot; or &quot;Options
IncludesNoExec&quot; at the top of your document tree, perhaps
as shown in Figure C&#173;4, and only turn the feature on for
subdirectories containing documents over which you have total
control. Even then be aware that perfectly&#173;secure scripts
are rare; many have non&#173;obvious shortcomings that can be
taken advantage of.<BR>
</BLOCKQUOTE>
<HR>
<PRE>
<FONT SIZE=2>&lt;Location /&gt;
    Options None
&lt;/Location&gt;</FONT>
</PRE>
<HR>

<PRE>
<CENTER><FONT SIZE=1>Figure C&#173;4
</FONT></CENTER>
</PRE>
<H1>SSI Directive Format</H1>
<P>
The basic SSI format looks like this:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#<I>directive</I> <I>[attributes]</I> &#173;&#173;&gt;

</FONT>
</PRE>
<P>
That format looks a lot like a regular standalone HTML tag, doesn't
it? That's really not surprising, since it <I>is</I> &#173; it's
a special case of the HTML comment tag. As such, the usual rules
concerning HTML tags apply, including:
<UL>
<LI>The tag name (&quot;<CODE>!&#173;&#173;</CODE>&quot; in this
case) <I>must not</I> contain any spaces, and there must be no
spaces between the opening broket (Hackish for &quot;broken bracket,&quot;
meaning &quot;<CODE>&lt;</CODE>&quot;) and the tag name.
<LI>Within the tag (between the &quot;<CODE>&lt;!&#173;&#173;</CODE>&quot;
and &quot;<CODE>&#173;&#173;&gt;</CODE>&quot;, that is), line&#173;breaks,
spaces, and TAB characters are legal between the tag attributes.
</UL>
<P>
Since this is a special case of the comment tag, however, there
are some <I>additional</I> rules you need to follow:
<UL>
<LI>Consider the &quot;<CODE>#<I><FONT SIZE=2 FACE="Courier New">directive</FONT></I></CODE>&quot;
portion to be part of the tag name &#173; in other words, the
tag name would be &quot;<CODE>&lt;!&#173;&#173;#include</CODE>&quot;
rather than just &quot;<CODE>&lt;!&#173;&#173;</CODE>&quot;. To
look at it another way, you can't insert any spaces between the
&quot;<CODE>&lt;!&#173;&#173;</CODE>&quot; and the &quot;<CODE>#<I><FONT SIZE=2 FACE="Courier New">directive</FONT></I></CODE>&quot;
parts.
<LI>You should <I>always</I> include a space before the final
&quot;<CODE>&#173;&#173;&gt;</CODE>&quot;! This is important;
if you don't include that space, the server may have difficulty
figuring out where the arguments end and the closing marker (&quot;<CODE>&#173;&#173;&gt;</CODE>&quot;)
begins.
<LI>Even if the value for a directive attribute is just a single
word, it's a good idea to enclose it in quotation marks.
</UL>
<P>
Given these rules, which of the following are syntactically valid
SSI directives?
<P>
1. <CODE>&lt;!&#173;&#173;#include virtual=&quot;foo.html&quot;
&#173;&#173;&gt;</CODE>
<P>
2. <CODE>&lt;!&#173;&#173; #include virtual=&quot;foo.html&quot;
&#173;&#173;&gt;</CODE>
<P>
3. <CODE>&lt;!&#173;&#173;#printenv&#173;&#173;&gt;</CODE>
<P>
4. <CODE>&lt;!&#173;&#173;#if expr=&quot;$A = 1&quot; &#173;&#173;&gt;</CODE>
<P>
5. <CODE>&lt;!&#173;&#173;#set var=&quot;ZED&quot; value=&quot;wanna&#173;cookie&quot;
&#173;&#173;&gt;</CODE>
<P>
You <I>should</I> have answered &quot;1, 4, and 5.&quot; The second
one has illegal space between the &quot;<CODE>&lt;!&#173;&#173;</CODE>&quot;
and the &quot;<CODE>#include</CODE>&quot;, and the third one is
missing the space before the &quot;<CODE>&#173;&#173;&gt;</CODE>&quot;.
<P>
<I><B>Tip: </B></I>Generally speaking, you <I>can not</I> insert
line&#173;breaks in the middle of quoted strings &#173; only between
elements <I>outside</I> of quoted SSI arguments:
<P>
1. Valid placement for a line&#173;break:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#exec
    cmd=&quot;cat a&#173;really&#173;long&#173;file&#173;name&quot; &#173;&#173;&gt;

</FONT>
</PRE>
<P>
2. Wrong&#173;o:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#exec cmd=&quot;cat
    a&#173;really&#173;long&#173;file&#173;name&quot; &#173;&#173;&gt;

</FONT>
</PRE>
<H1><A NAME="_Toc403834021">SSI Variables</A></H1>
<P>
Since server&#173;side includes involve active evaluation of the
document source by the server, it makes a set of variables available
so the directives can use them to make decisions. All of the variables
that are available for CGI scripts are defined in the SSI processing
environment. In addition, the server defines the following variables
which pertain specifically to the SSI environment itself:
<PRE>
<FONT SIZE=2>* </FONT><CODE>DATE_GMT
</CODE>
</PRE>
<P>
The current date in Greenwich Mean Time. This is subject to the
current time display format (see the description of the &quot;<CODE>#config</CODE>&quot;
SSI directive in the next section).
<PRE>
<FONT SIZE=2>* </FONT><CODE>DATE_LOCAL
</CODE>
</PRE>
<P>
The current date in the local time zone. (Local to the server,
that is, not to the client.) This is also converted according
to the current time format in effect.
<PRE>
<FONT SIZE=2>* </FONT><CODE>DOCUMENT_NAME
</CODE>
</PRE>
<P>
The filename (excluding any parent directories) of the document
requested by the client.
<PRE>
<FONT SIZE=2>* </FONT><CODE>DOCUMENT_URI
</CODE>
</PRE>
<P>
The URL path of the document requested by the client, after any
URL encoding has been decoded (<I>e.g.</I>, &quot;<CODE>%2F</CODE>&quot;
replaced with &quot;<CODE>/</CODE>&quot;, &quot;<CODE>%20</CODE>&quot;
replaced with a space, <I>et cetera</I>). Note that in the case
of nested include files, this is <I>not</I> the URL for the current
document.
<PRE>
<FONT SIZE=2>* </FONT><CODE>LAST_MODIFIED
</CODE>
</PRE>
<P>
The last modification date of the document requested by the user.
Like other dates, this one is converted according to the current
time format string.
<P>
All of these variables are set when the server begins parsing
the main document requested by the client. They are not altered
if and when the server has to handle a nested document, although
the display format for dates and files sizes may change according
to the most recent <CODE>#config</CODE> directive the server has
run into.
<P>
<I><B>Tip: </B></I>Variables are <I>always</I> regarded as having
text values rather than numeric ones. If you compare a variable
that contains 12 to one that contains 2, the second one will be
considered larger &#173; because the string &quot;2&quot; gets
listed later than the string &quot;12&quot;.
<P>
For a description of the other variables provided by the Apache
Web server, see Chapter 12. In addition, you can change these
or set or modify your own variables using the <CODE>#set</CODE>
SSI directive, which is described in the next section.
<H2><A NAME="_Toc403834022">Substitution of SSI variables</A>
</H2>
<P>
You can use the variables that are available to you to help control
the content and formatting of your document (see the section on
&quot;Conditional Inclusion&quot; later in this appendix). They
can't appear in the normal text, though &#173; they can only be
used within SSI directives. If you want their values to show up
in the actual text of the document, you need to use the <CODE>#echo</CODE>
directive to make it happen.
<P>
Variables can only be used under certain circumstances and with
particular directives. Sometimes you refer to them by name and
sometimes you request that their values be substituted instead.
<P>
The four SSI directives that can deal with variables are <CODE>#echo</CODE>,
<CODE>#set</CODE>, <CODE>#if</CODE>, and <CODE>#elif</CODE>. <CODE>#echo</CODE>
always refers to variables by name, <CODE>#set</CODE> sometimes
by name and sometimes by substitution, and the <CODE>#if</CODE>
and <CODE>#elif</CODE> only by substitution.
<P>
What do I mean by &quot;substitution?&quot; Well, any time you
want to use a variable's value, you need to indicate that it be
<I>substituted</I> for the name. You indicate that the value should
be used instead of the name by putting a dollar&#173;sign (<CODE>$</CODE>)
in front of the name.
<P>
That's incredibly clear, isn't it? <I>Not</I>. Okay, let me try
an example. . .
<P>
The <CODE>#set</CODE> directive takes two attributes, the name
of a variable to set and the value to set it to. Here's what it
looks like:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#set var=&quot;V1&quot; value=&quot;23&quot; &#173;&#173;&gt;
</FONT>
</PRE>
<P>
This unconditionally stores the value &quot;<CODE>23</CODE>&quot;
in the variable named <CODE>V1</CODE> (creating the variable if
it has to). The &quot;<CODE>var</CODE>&quot; attribute of the
<CODE>#set</CODE> directive <I>always</I> refers to variables
by name.
<P>
Now, if we want to set the variable <CODE>V2</CODE> to &quot;<CODE>23</CODE>&quot;
too, either of the following will work:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#set var=&quot;V2&quot; value=&quot;23&quot; &#173;&#173;&gt;
&lt;!&#173;&#173;#set var=&quot;V2&quot; value=&quot;$V1&quot; &#173;&#173;&gt;

</FONT>
</PRE>
<P>
The second line works by <I>substituting</I> the value of the
<CODE>V1</CODE> variable in place of its name.
<P>
When I said that <CODE>#set</CODE>'s &quot;<CODE>var</CODE>&quot;
attribute always took a name, it meant that
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#set var=&quot;NAME&quot; value=&quot;V1&quot; &#173;&#173;&gt;
&lt;!&#173;&#173;#set var=&quot;$NAME&quot; value=&quot;23&quot; &#173;&#173;&gt;

</FONT>
</PRE>
<P>
creates two variable named &quot;<CODE>NAME</CODE>&quot; and &quot;<CODE>$NAME</CODE>&quot;,
and is <I>not</I> the same as
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#set var=&quot;NAME&quot; value=&quot;V1&quot; &#173;&#173;&gt;
&lt;!&#173;&#173;#set var=&quot;V1&quot; value=&quot;23&quot; &#173;&#173;&gt;

</FONT>
</PRE>
<P>
<I><B>Warning: </B></I>While dollar&#173;signs are allowed in
variable names, it's tricky to use them, and I highly recommend
that you avoid it.
<P>
So much for #set &#173; one of its attributes (<CODE>var</CODE>)
uses variables by name, and the other (<CODE>value</CODE>) can
use substitutions. Let's take a quick look at the other directives
I mentioned before getting into the fancy stuff.
<P>
The &quot;<CODE>var</CODE>&quot; attribute to the <CODE>#echo</CODE>
directive is just like the one for the <CODE>#set</CODE> directive
&#173; it always treats what you give it as a variable name. So
the following would cause the server to replace the entire directive
with the text &quot;<CODE>23</CODE>&quot; before sending it to
the client:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#echo var=&quot;V1&quot; &#173;&#173;&gt;

</FONT>
</PRE>
<P>
On the other hand, the following would each get replaced with
the text &quot;<CODE>(none)</CODE>&quot; because the variables
<CODE>OOPS</CODE> and <CODE>$OOPS</CODE> don't exist:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#echo var=&quot;OOPS&quot; &#173;&#173;&gt;
&lt;!&#173;&#173;#echo var=&quot;$OOPS&quot; &#173;&#173;&gt;

</FONT>
</PRE>
<P>
On the other hand, the <CODE>#if</CODE> and <CODE>#elif</CODE>
directives <I>always</I> allow substitution. In fact, if you don't
put a dollar&#173;sign in front of a variable name, they don't
even know it <I>is</I> one &#173; they think it's just a normal
string! So the first #if below would be considered true, but the
second one would be false:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#if expr=&quot;$V1 = 23&quot; &#173;&#173;&gt;
&lt;!&#173;&#173;#if expr=&quot;V1 = 23&quot; &#173;&#173;&gt;

</FONT>
</PRE>
<H2><A NAME="_Toc403834023">Variable concatenation</A></H2>
<P>
&quot;Concatenation&quot; is just an expensive word that means
to put things together in sequence, like pearls on a string. In
the case of variables and server&#173;side includes, it means
using substitution to put together strings using substitution.
<P>
To concatenate strings, it's simple: you just do it. For example,
if you want to set variable <CODE>V1</CODE> to the value of <CODE>V2</CODE>
with an &quot;<CODE>x</CODE>&quot; in front of it, you'd do it
like this:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#set var=&quot;V1&quot; value=&quot;x$V2&quot; &#173;&#173;&gt;

</FONT>
</PRE>
<P>
See how the &quot;<CODE>x</CODE>&quot; and the value (through
substitution) are just smooshed together? That's all there is
to it? If you want to set <CODE>V3</CODE> to the values of <CODE>V1</CODE>
and <CODE>V2</CODE> put together, here's how:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#set var=&quot;V3&quot; value=&quot;$V1$V2&quot; &#173;&#173;&gt;

</FONT>
</PRE>
<P>
You can obviously expand this to expressions as complex as you
like.
<P>
If you want to include quotation marks (<CODE>&quot;</CODE>) in
your values, you need to <I>escape</I> them by preceding them
with a slosh (Hackish nickname for the backslash character, &quot;<CODE>\</CODE>&quot;),
like this:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#set var=&quot;V3&quot; value=&quot;$V1\&quot;$V2\&quot;$V1&quot; &#173;&#173;&gt;

</FONT>
</PRE>
<P>
That would cause <CODE>V3</CODE>'s value to include the quotation
marks around the value of <CODE>V2</CODE>.
<P>
Finally, if you need to include a bunch of spaces in an expression,
you can put quotation marks or tick&#173;marks (another nick&#173;name,
this time for the apostrophe or single&#173;quote character) around
it like so:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#if expr=&quot;$V1 = '$V2    $V3  xyz'&quot; &#173;&#173;&gt;

</FONT>
</PRE>
<P>
Without the ticks, the server would get confused about what it
was supposed to compare, because it would collapse those extra
spaces down to just one apiece.
<H2><A NAME="_Toc403834024">Disambiguation</A></H2>
<P>
&quot;Disambiguation&quot; is another hundred&#173;thousand&#173;credit
word that simply means &quot;making sure you know what's what.&quot;
For instance, what if you want to set variable <CODE>V1</CODE>
to the value of <CODE>V2</CODE> with an &quot;<CODE>x</CODE>&quot;
in front and a &quot;<CODE>y</CODE>&quot; after it? You might
try something like this:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#set var=&quot;V1&quot; value=&quot;x$V2y&quot; &#173;&#173;&gt;

</FONT>
</PRE>
<P>
But wait! Would that work? How is the server supposed to know
that you want to use the value of the variable &quot;<CODE>V2</CODE>&quot;,
and not the (possibly nonexistent) variable &quot;<CODE>V2y</CODE>&quot;?
It can't &#173; which is why you need to <I>disambiguate</I> the
expression.
<P>
You make it clear to the Apache Web server where your variable
names begin and end during substitution by putting braces (&quot;<CODE>{</CODE>&quot;
and &quot;<CODE>}</CODE>&quot;) around them, like this:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#set var=&quot;V1&quot; value=&quot;x${V2}y&quot; &#173;&#173;&gt;

</FONT>
</PRE>
<P>
This will have the desired effect of making V1 equal to &quot;<CODE>x23y</CODE>&quot;
(assuming <CODE>V2</CODE> was set to &quot;<CODE>23</CODE>&quot;,
that is).
<P>
There! Now you should be able to disambiguate at need. Give yourself
10 Apache Guru Points for sticking with it.
<H1><A NAME="_Toc403834025">SSI Directive Dictionary</A></H1>
<P>
The Apache Web server supports an even dozen server&#173;side
include directives. They fall into three basic functional categories:
<UL>
<LI>Directives that affect the environment,
<LI>Directives that substitute (&quot;include&quot;) content in
the document before it's sent to the client, and
<LI>Directives that allow you to choose what content is processed
or sent (&quot;conditional processing&quot;).
</UL>
<P>
The &quot;environmental&quot; directives allow you to change how
certain &quot;included&quot; values are displayed (such as the
format of dates), or modify settings that can be checked by the
conditional directives.
<P>
The &quot;include&quot; directives can actually pull in other
documents into the middle of the current one, or drag in the output
from a script, or display information about various things (such
as the current settings or the size of a file).
<P>
The &quot;conditional&quot; directives do exactly that &#173;
they let you do things like instruct the server to &quot;send
this paragraph is the client is X, or send <I>that</I> paragraph
otherwise.&quot; This allows a single document to have a different
look depending upon the situation &#173; for instance, you can
use this to format the page according to whether the client supports
window frames, or maybe tables.
<P>
<I><B>Technical Stuff:</B></I> &quot;Frames&quot; are an enhancement
to the basic HTML language that allow you to instruct the browser
to divide its window up into multiple sub&#173;windows or panes
&#173; basically telling it where to add additional &quot;windows&quot;
within the actual display. Hence the name, from &quot;window frames.&quot;
Each frame can be managed separated by the browser and the end
user, including scrolling them independently, which can be neat
for things like displaying footnotes at the bottom of the screen
regardless of what part of the main text is displayed, or keeping
an index or table of contents visible in a sidebar. Figure C&#173;5
illustrates frames.
<HR>
<P>
<CENTER>(see separate file on CD-ROM)</CENTER>
<HR>
<P>
<CENTER><FONT SIZE=1>Figure C&#173;5</FONT></CENTER>
<P>
All of the server&#173;side include directives are described,
in alphabetical order, in the following sections.
<H2><A NAME="_Toc403834026"><CODE>config</CODE> &#173; Environmental
directive</A></H2>
<P>
The <CODE>config</CODE> SSI directive allows to change the format
of various things the server can substitute, such as dates or
numbers. Settings only apply to the current request; each new
request starts with them at their default values. Within a single
request they apply until changed or overridden.
<P>
The valid attributes are:
<PRE>
<FONT SIZE=2>* </FONT><CODE>errmsg=&quot;<I><FONT SIZE=2 FACE="Courier New">alternate message text</FONT></I>&quot;
</CODE>
</PRE>
<BLOCKQUOTE>
The value is a message that is sent back to the client if an error
occurs whilst parsing the document. You can use this to change
the default error text, which can be really useful if the rest
of the page is in some language other than English. Here's an
example of how you can tailor the message to give more of a hint
about the problem if something fails:
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>   &lt;!&#173;&#173;#config errmsg=&quot;[#include failed]&quot; &#173;&#173;&gt;
   &lt;!&#173;&#173;#include virtual=&quot;foo.html&quot; &#173;&#173;&gt;
   &lt;!&#173;&#173;#config errmsg=&quot;[an error occurred processing this directive]&quot; &#173;&#173;&gt;
* </FONT><CODE>sizefmt=&quot;<I><FONT SIZE=2 FACE="Courier New">bytes&#173;or&#173;abbrev</FONT></I>&quot;
</CODE>
</PRE>
<BLOCKQUOTE>
The value sets the format to be used which displaying the size
of a file. Valid values are <CODE>bytes</CODE> for a count in
bytes, or <CODE>abbrev</CODE> for a count in kilobytes (KB) or
megabytes (MB) as appropriate. Consider the following for the
file <CODE>foo.html</CODE> if it were 1200 bytes long:
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>    &lt;!&#173;&#173;#config sizefmt=&quot;bytes&quot; &#173;&#173;&gt;
    foo.html contains 
        &lt;!&#173;&#173;#fsize virtual=&quot;foo.html&quot; &#173;&#173;&gt; bytes
    &lt;BR&gt;
    &lt;!&#173;&#173;#config sizefmt=abbrev &#173;&#173;&gt;
    The abbreviated size of foo.html is
        &lt;!&#173;&#173;#fsize virtual=&quot;foo.html&quot; &#173;&#173;&gt;
</FONT>
</PRE>
<BLOCKQUOTE>
The output displayed by the client would look like this:
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>    foo.html contains 1200 bytes
    The abbreviated size of foo.html is 1Kb

* </FONT><CODE>timefmt=&quot;<I><FONT SIZE=2 FACE="Courier New">format&#173;string</FONT></I>&quot;
</CODE>
</PRE>
<BLOCKQUOTE>
This attribute allows you to control the format in which the server
will display dates when they're substituted. The &quot;format&#173;string&quot;
value is a string defining the format in terms understandable
by the <CODE>strftime()</CODE> library routine. For instance,
assume <CODE>foo.html</CODE> was last changed on the 7th of November,
1997, at 5:30 in the afternoon &#173; what happens if we push
that through the SSI parser with the HTML fragment below?
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>      foo.html last changed:
         &lt;!&#173;&#173;#flastmod virtual=&quot;foo.html&quot; &#173;&#173;&gt;
      &lt;BR&gt;
      &lt;!&#173;&#173;#config timefmt=&quot;%Y&#173;%m&#173;%d %H:%S %Z&quot; &#173;&#173;&gt;
      foo.html last changed:
         &lt;!&#173;&#173;#flastmod virtual=&quot;foo.html&quot; &#173;&#173;&gt;
</FONT>
</PRE>
<BLOCKQUOTE>
When actually sent to the client, here's what would be displayed:
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>   foo.html last changed: Fri, 7 Nov 1997 17:30 GMT
   foo.html last changed: 1997&#173;11&#173;07 17:30 GMT


</FONT>
</PRE>
<BLOCKQUOTE>
The actual conversion specifiers available depend upon the platform
you're using for your Apache Web server, but here are some common
ones:
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%a
</CODE>
</PRE>
<BLOCKQUOTE>
Causes the abbreviated weekday name (<I>e.g.,</I> &quot;Mon&quot;
instead of &quot;Monday&quot;) to be inserted.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%A
</CODE>
</PRE>
<BLOCKQUOTE>
Inserts the full name of the day of the week.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%b
</CODE>
</PRE>
<BLOCKQUOTE>
The server will insert the abbreviated name of the month (<I>e.g.</I>,
&quot;Jan&quot; instead of &quot;January&quot;).
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%B
</CODE>
</PRE>
<BLOCKQUOTE>
Causes the full month&#173;name to be inserted.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%c
</CODE>
</PRE>
<BLOCKQUOTE>
Inserts the date &amp; time in the system's preferred default
format.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I><B>Warning: </B></I>This &quot;preferred&quot; format is almost
certainly <I>not</I> going to be the same as the default format
used by the Apache Web server, so you shouldn't use this to return
the format to it's original state. Use the format listed at the
end of this section for that.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%d
</CODE>
</PRE>
<BLOCKQUOTE>
The Apache Web server will insert the day of the month as a two&#173;digit
value (<I>i.e.</I>, &quot;01&quot; through &quot;31&quot;) for
this conversion.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%H
</CODE>
</PRE>
<BLOCKQUOTE>
Inserts the hour of the day as a two&#173;digit value, based upon
a 24&#173;hour clock. (That is, the value inserted will be in
the range of &quot;01&quot; through &quot;23&quot;.)
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%I
</CODE>
</PRE>
<BLOCKQUOTE>
Inserts the hour of the day, using two digits based upon a 12&#173;hour
clock (<I>e.g.</I>, &quot;01&quot; through &quot;12).
</BLOCKQUOTE>
<BLOCKQUOTE>
<I><B>Tip: </B></I>If you use this conversion specifier, you really
should follow it with &quot;<CODE>%p</CODE>&quot; so that the
AM&#173; or PM&#173;ness of the hour is clear.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%j
</CODE>
</PRE>
<BLOCKQUOTE>
Causes the server to insert the day of the year as a three&#173;digit
value in the range &quot;001&quot; through &quot;366&quot;.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%m
</CODE>
</PRE>
<BLOCKQUOTE>
Inserts the month of the year as a two&#173;digit number in the
range &quot;01&quot; through &quot;12&quot;.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%M
</CODE>
</PRE>
<BLOCKQUOTE>
Causes the minute to be inserted as a two&#173;digit number.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%p
</CODE>
</PRE>
<BLOCKQUOTE>
Inserts one of the strings &quot;<CODE>am</CODE>&quot; or &quot;<CODE>pm</CODE>&quot;,
according to the time of day being displayed.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%S
</CODE>
</PRE>
<BLOCKQUOTE>
Inserts the number of seconds as a two&#173;digit number.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%U
</CODE>
</PRE>
<BLOCKQUOTE>
This will cause the server to insert the week of the year as a
number, counting the first Sunday of the year as the first day
of the first week. (This can be misleading if January 1st happens
to fall on a Monday for the year in question!)
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%w
</CODE>
</PRE>
<BLOCKQUOTE>
Causes the day of the week to be inserted as a single digit, with
Sunday represented as &quot;0&quot; and Saturday as &quot;6&quot;.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%W
</CODE>
</PRE>
<BLOCKQUOTE>
Similar to &quot;<CODE>%U</CODE>&quot; except that weeks are treated
as starting on Monday rather than Sunday, and the first Monday
of the year is considered to be the first day of the first week.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%x
</CODE>
</PRE>
<BLOCKQUOTE>
Inserts the date in the system's preferred default format &#173;
which is probably <I>not</I> the same as Apache's preferred default!
Use this with care. The time is not included.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%X
</CODE>
</PRE>
<BLOCKQUOTE>
Causes the server to insert the time (but not the date) in the
system's preferred default format.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%y
</CODE>
</PRE>
<BLOCKQUOTE>
Inserts the year as a two&#173;digit number (&quot;00&quot; through
&quot;99&quot;).
</BLOCKQUOTE>
<BLOCKQUOTE>
<I><B>Warning: </B></I>As you might expect, this format is <I>not</I>
Year 2000&#173;safe. You should use the &quot;<CODE>%Y</CODE>&quot;
conversion specifier instead if at all possible.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%Y
</CODE>
</PRE>
<BLOCKQUOTE>
Inserts the year as a four&#173;digit number.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%Z
</CODE>
</PRE>
<BLOCKQUOTE>
Causes the timezone information to be inserted (<I>e.g.</I>, &quot;GMT&quot;,
&quot;EDT&quot;, &quot;MST&quot;, and so on).
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>%%
</CODE>
</PRE>
<BLOCKQUOTE>
Since the conversion specifiers all start with a percent symbol
(%), there needs to be a way to actually include the percent symbol
itself if you want it to show up in the output. You do this by
including &quot;<CODE>%%</CODE>&quot; in the format string.
</BLOCKQUOTE>
<BLOCKQUOTE>
The default format the Apache Web server will use (until you override
it) is:
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>%A, %d&#173;%b&#173;%y %H:%M:%S %Z

</FONT>
</PRE>
<BLOCKQUOTE>
If you want to return the time format string to its original setting,
you should include a <CODE>#config</CODE> SSI directive that sets
it to this value.
</BLOCKQUOTE>
<BLOCKQUOTE>
You can specify more than one attribute in a single <CODE>config</CODE>
directive:
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#config sizefmt=&quot;bytes&quot; errmsg=&quot;[SSI parse failure]&quot; &#173;&#173;&gt;
</FONT>
</PRE>
<H2><A NAME="_Toc403834027"><CODE>echo</CODE> &#173; Include directive</A>
</H2>
<P>
The Apache Web server will replace occurrences of the <CODE>#echo</CODE>
SSI directive with the value of the variable named in the directive.
If the variable isn't defined, the server will substitute &quot;<CODE>(none)</CODE>&quot;
instead. If the server recognizes the variable as containing a
date, it will be substituted according to the <CODE>timefmt</CODE>
format string currently in effect (see the previous section for
more information about time formats).
<P>
The <CODE>#echo</CODE> directive takes a single attribute:
<PRE>
<FONT SIZE=2>* </FONT><CODE>var=&quot;<I><FONT SIZE=2 FACE="Courier New">variable&#173;name</FONT></I>&quot;
</CODE>
</PRE>
<BLOCKQUOTE>
The value is the name of the variable to print, and can be any
of the predefined SSI variables (described in the section by that
name earlier in this chapter), CGI variables (described in Appendix
C), or variables you have set using the <CODE>#set</CODE> SSI
directive (described later in this section).
</BLOCKQUOTE>
<BLOCKQUOTE>
<I><B>Technical Stuff: </B></I>Variable names are <I>not</I> case&#173;sensitive;
that is, &quot;ZED&quot; and &quot;Zed&quot; refer to the same
variable. All of the predefined CGI and SSI variable names are
specified in all&#173;uppercase by the server, but you can refer
to them in either upper&#173; or lower&#173;case. Be careful when
creating or modifying variables with the <CODE>#set</CODE> SSI
directive that you aren't wiping out the wrong one.
</BLOCKQUOTE>
<H2><A NAME="_Toc403834028"><CODE>elif</CODE> &#173; Conditional
directive</A></H2>
<P>
&quot;Elif&quot; is an abbreviation for &quot;else if.&quot; The
<CODE>#elif</CODE> SSI directive can only appear after an <CODE>#if</CODE>
SSI directive or another <CODE>#elif</CODE>. It allows you to
do conditional processing of the sort &quot;If <I>x</I> then do
A, else if <I>y</I> then do B, otherwise do C.&quot;
<P>
The syntax for the <CODE>#elif</CODE> SSI directive is:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#elif expr=&quot;<I>conditional&#173;expression</I>&quot; &#173;&#173;&gt;
</FONT>
</PRE>
<P>
For more information about using it, see the section on &quot;Conditional
Inclusion&quot; later in this appendix.
<H2><A NAME="_Toc403834029"><CODE>else</CODE> &#173; Conditional
directive</A></H2>
<P>
The <CODE>#else</CODE> SSI directive is used to declare an alternative
when the server is performing conditional inclusion. It handles
the &quot;otherwise&quot; case in a decision like &quot;If <I>x</I>
then do A, otherwise do C.&quot; The format of the directive is:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#else &#173;&#173;&gt;
</FONT>
</PRE>
<P>
Simple, no? For more information about its use, please see the
section later in this appendix entitled &quot;Conditional Inclusion.&quot;
<H2><A NAME="_Toc403834030"><CODE>endif</CODE> &#173; Conditional
directive</A></H2>
<P>
This SSI directive is used to mark the end of a conditional inclusion
block. The format is:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#endif &#173;&#173;&gt;
</FONT>
</PRE>
<P>
Conditional inclusion is described in detail later in this appendix,
and that's where you'll find more information about this directive.
<H2><A NAME="_Toc403834031"><CODE>exec</CODE> &#173; Include directive</A>
</H2>
<P>
The <CODE>#exec</CODE> SSI directive executes a given shell command
or CGI script, and replaces the directive with the output. If
the current scope includes the keyword <CODE>IncludesNoExec</CODE>
on an <CODE>Option</CODE> directive, this functionality is completely
disabled within that scope.
<P>
The valid attributes are:
<PRE>
<FONT SIZE=2>* </FONT><CODE>cgi=&quot;<I><FONT SIZE=2 FACE="Courier New">CGI&#173;script&#173;name</FONT></I>&quot;
</CODE>
</PRE>
<BLOCKQUOTE>
The value specifies an encoded URL path to the CGI script. (That
is, any special characters in the URL must have been encoded;
spaces replaced with &quot;<CODE>+</CODE>&quot; or &quot;<CODE>%20</CODE>&quot;,
and so on.) If the path does not begin with a slash (<CODE>/</CODE>),
then it is taken to be relative to the current document. The document
referenced by this path is invoked as a CGI script, even if the
server would not normally recognize it as such. However, the directory
containing the script <CODE>must</CODE> be enabled for CGI scripts
(with the <CODE>ScriptAlias</CODE> directive or the <CODE>ExecCGI</CODE>
keyword on an <CODE>Option</CODE> directive).
</BLOCKQUOTE>
<BLOCKQUOTE>
The CGI script is given the <CODE>PATH_INFO</CODE> and argument
(<CODE>QUERY_STRING</CODE>) of the original request from the client;
these cannot be specified in the URL path. The SSI environment
variables will be available to the script in addition to the standard
CGI environment.
</BLOCKQUOTE>
<BLOCKQUOTE>
If the script returns a <CODE>Location:</CODE> header instead
of output, then this will be translated into an HTML anchor in
the including document before it is sent to the client.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I><B>Tip: </B></I>The &quot;<CODE>#include virtual</CODE>&quot;
SSI directive should be used in preference to &quot;<CODE>#exec
cgi</CODE>&quot;.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>cmd=&quot;<I><FONT SIZE=2 FACE="Courier New">shell&#173;command&#173;string</FONT></I>&quot;
</CODE>
</PRE>
<BLOCKQUOTE>
The server will execute the given string using <CODE>/bin/sh</CODE>.
The SSI variables are available to the command as normal shell
environment variables.
</BLOCKQUOTE>
<BLOCKQUOTE>
You may only specify one of these attributes in a single <CODE>#exec</CODE>
directive. Naturally, the script or command you specify must be
executable by the server user.
</BLOCKQUOTE>
<H2><A NAME="_Toc403834032"><CODE>flastmod</CODE> &#173; Include
directive</A></H2>
<BLOCKQUOTE>
This SSI directive is replaced by the last modification date of
the specified file, subject to the <CODE>timefmt</CODE> format
specification currently in force (see the description of the &quot;<CODE>#config</CODE>&quot;
SSI directive earlier in this appendix). Attributes for this directive
are:
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>file=&quot;<I><FONT SIZE=2 FACE="Courier New">file&#173;path</FONT></I>&quot;
</CODE>
</PRE>
<BLOCKQUOTE>
The value is a path relative to the directory containing the current
file being parsed. For instance,
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#flastmod file=&quot;zinc/foo.txt&quot; &#173;&#173;&gt;
</FONT>
</PRE>
<BLOCKQUOTE>
refers to the file <CODE>foo.txt</CODE> in the <CODE>zinc</CODE>
subdirectory below the current document's directory.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I><B>Tip: </B></I>The file specification used in this syntax
may not begin with a slash, nor may it contain upward references
that would point to a file outside the current directory's scope.
That is, it can't start with &quot;<CODE>/</CODE>&quot; or contain
the string &quot;<CODE>/../</CODE>&quot;.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>virtual=&quot;<I><FONT SIZE=2 FACE="Courier New">document&#173;path</FONT></I>&quot;
</CODE>
</PRE>
<BLOCKQUOTE>
The value is a URL&#173;path (<I>not</I> a filesystem path) relative
to the current document being parsed. Any special characters must
be URL&#173;encoded (<I>i.e.</I>, spaces replaced with &quot;<CODE>+</CODE>&quot;
or &quot;<CODE>%20</CODE>&quot;, quotation marks with &quot;<CODE>%22</CODE>&quot;,
and so forth). If the specified path does not begin with a slash
(<CODE>/</CODE>) then it is taken to be relative to the current
document. If it starts with a slash, it's interpreted relative
to the server's <CODE>DocumentRoot</CODE>.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#flastmod virtual=&quot;/zinc/foo.txt&quot; &#173;&#173;&gt;
</FONT>
</PRE>
<BLOCKQUOTE>
This will cause the server to insert the modification date of
the file <CODE>foo.txt</CODE> from the location that maps to <CODE>${DocumentRoot}/zinc/</CODE>,
including any appropriate alias processing.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I><B>Tip: </B></I>Note that &quot;<CODE>file</CODE>&quot; refers
to the included document's location in the filesystem's directory
structure, while &quot;<CODE>virtual</CODE>&quot; refers to its
location in the Web namespace.
</BLOCKQUOTE>
<BLOCKQUOTE>
You may only specify one of these attributes in a single <CODE>#flastmod</CODE>
directive.
</BLOCKQUOTE>
<H2><A NAME="_Toc403834033"><CODE>fsize</CODE> &#173; Include
directive</A></H2>
<P>
This SSI directive causes the Apace Web server to substitute the
size of the specified file in the document being parsed, subject
to the current setting of the <CODE>sizefmt</CODE> format specification
(see the description of the &quot;<CODE>#config</CODE>&quot; SSI
directive earlier in this appendix). Attributes for this directive
are:
<PRE>
<FONT SIZE=2>* </FONT><CODE>file=&quot;<I><FONT SIZE=2 FACE="Courier New">file&#173;path</FONT></I>&quot;
</CODE>
</PRE>
<P>
The value is a path relative to the directory containing the current
file being parsed.
<P>
<I><B>Tip: </B></I>The file specification used in this syntax
may not begin with a slash, nor may it contain upward references
that would point to a file outside the current directory's scope.
That is, it can't start with &quot;<CODE>/</CODE>&quot; or contain
the string &quot;<CODE>/../</CODE>&quot;.
<PRE>
<FONT SIZE=2>* </FONT><CODE>virtual=&quot;<I><FONT SIZE=2 FACE="Courier New">document&#173;path</FONT></I>&quot;
</CODE>
</PRE>
<P>
The value is a URL&#173;path (<I>not</I> a filesystem path) relative
to the current document being parsed. Any special characters must
be URL&#173;encoded (<I>i.e.</I>, spaces replaced with &quot;<CODE>+</CODE>&quot;
or &quot;<CODE>%20</CODE>&quot;, quotation marks with &quot;<CODE>%22</CODE>&quot;,
and so forth). If the specified path does not begin with a slash
(<CODE>/</CODE>) then it's regarded as relative to the current
document. If it does start with a slash, it's treated as being
relative to the server's <CODE>DocumentRoot</CODE>.
<P>
<I><B>Remember: </B></I>Note that &quot;<CODE>file</CODE>&quot;
refers to the included document's location in the filesystem's
directory structure, while &quot;<CODE>virtual</CODE>&quot; refers
to its location in the Web namespace.
<P>
You may only specify one of these attributes in a single <CODE>#fsize</CODE>
directive.
<H2><A NAME="_Toc403834034"><CODE>if</CODE> &#173; Conditional
directive</A></H2>
<P>
The <CODE>#if</CODE> SSI directive introduces a conditional processing
section. The syntax for this directive is:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#if expr=&quot;<I>conditional&#173;expression</I>&quot; &#173;&#173;&gt;
</FONT>
</PRE>
<P>
It's used in conjunction with the <CODE>#else</CODE>, <CODE>#elif</CODE>,
and <CODE>#endif</CODE> SSI directives to control what portions
of the document the server will include (or exclude) when it sends
the parsed result to the client.
<P>
See the &quot;Conditional Inclusion&quot; section later in this
appendix for more information.
<H2><A NAME="_Toc403834035"><CODE>include</CODE> &#173; Include
directive</A></H2>
<P>
This SSI directive inserts the text of another document or file
into the one currently being parsed. Any included file is subject
to the usual access control. If the document being included would
cause the server to execute an external script or command, the
directory of the file being parsed (<I>not</I> the one being included)
must be within the scope of an &quot;<CODE>Options ExecCGI</CODE>&quot;
directive or the inclusion will not be performed.
<P>
CGI scripts are invoked as normal using the complete URL given
in the directive, including any query string or path information.
Note that this differs from the way they get invoked by the &quot;<CODE>#exec
cgi=</CODE>&quot; SSI directive (described a few sections ago).
<P>
The valid attributes are: 
<PRE>
<FONT SIZE=2>* </FONT><CODE>file=&quot;<I><FONT SIZE=2 FACE="Courier New">file&#173;path</FONT></I>&quot;
</CODE>
</PRE>
<BLOCKQUOTE>
The value is a path relative to the directory containing the current
document being parsed. The path cannot start with a slash (<CODE>/</CODE>),
nor may it contain the string &quot;/../&quot;
</BLOCKQUOTE>
<BLOCKQUOTE>
<I><B>Tip: </B></I>The &quot;<CODE>#include virtual=</CODE>&quot;
syntax should <I>always</I> be used in preference to &quot;<CODE>#include
file=</CODE>&quot;. The latter is primarily maintained for backward
compatibility.
</BLOCKQUOTE>
<PRE>
<FONT SIZE=2>* </FONT><CODE>virtual=&quot;<I><FONT SIZE=2 FACE="Courier New">document&#173;path</FONT></I>&quot;
</CODE>
</PRE>
<BLOCKQUOTE>
The value is a URL that points to the document to be included.
The URL cannot contain a scheme or hostname, only a path, an optional
path information string, and an optional query string. If it does
not begin with a slash (<CODE>/</CODE>) then it is taken to be
relative to the document into which it is being included. If it
<I>does</I> begin with a slash, it's treated as being relative
to the server's <CODE>DocumentRoot</CODE>.
</BLOCKQUOTE>
<BLOCKQUOTE>
A URL is constructed from the specified value, and the output
the server would return if the URL were accessed by the client
is included in the parsed output. Thus included files can be nested.
</BLOCKQUOTE>
<BLOCKQUOTE>
The document or file being included must be accessible to the
server user. You may combine multiple <CODE>file</CODE> or <CODE>virtual</CODE>
attributes in a single <CODE>#include</CODE> SSI directive.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I><B>Tip: </B></I>Unlike the &quot;<CODE>#exec</CODE>&quot; SSI
directive, the <CODE>IncludesNoExec</CODE> option has <I>no effect</I>
on CGI scripts executed and included with the &quot;<CODE>#include
virtual</CODE>&quot; directive. Only the <CODE>ExecCGI</CODE>
option affects this operation.
</BLOCKQUOTE>
<H2><A NAME="_Toc403834036"><CODE>printenv</CODE> &#173; Include
directive</A></H2>
<P>
When the Apache Web server encounters this SSI directive in a
document it is parsing, it will replace it with a display of all
of the current variables and their settings. The directive takes
no attributes, and has the following syntax: 
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#printenv &#173;&#173;&gt;
</FONT>
</PRE>
<P>
<I><B>Tip: </B></I>Because of the way browsers handle HTML, it's
a good idea to enclose this directive within a &quot;preformatted
text&quot; (<CODE>&lt;PRE&gt;</CODE>) container, like this:
<PRE>
<FONT SIZE=2>&lt;PRE&gt;
&lt;!&#173;&#173;#printenv &#173;&#173;&gt;
&lt;/PRE&gt;
</FONT>
</PRE>
<P>
Otherwise the display you get is likely to be barely readable.
<H2><A NAME="_Toc403834037"><CODE>set</CODE> &#173; Environmental
directive</A></H2>
<P>
If you've been reading along with me, you should remember that
I've mentioned a number of times that you can use SSI directives
to create new variables or modify existing ones. (If you haven't
been reading along, that's all right &#173; just take my word
for it that you can do this.) This is the directive that lets
you do that. It takes two attributes and has a syntax like this:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#set var=&quot;<I>variable&#173;name</I>&quot; value=&quot;<I>string</I>&quot; &#173;&#173;&gt;
* </FONT><CODE>var
</CODE>
</PRE>
<P>
The name of the variable to set.
<P>
<I><B>Remember:</B></I> Remember that variable names are <I>not</I>
case&#173;sensitive; &quot;<CODE>ZED</CODE>&quot; and &quot;<CODE>Zed</CODE>&quot;
refer to the same variable!
<PRE>
<FONT SIZE=2>* </FONT><CODE>value
</CODE>
</PRE>
<P>
The value to give to the variable. Unlike the variable name, the
value <I>is</I> case&#173;sensitive. Whatever value you specify
is assigned explicitly to the variable without any case&#173;conversion.
<P>
Both the <CODE>var</CODE> and <CODE>value</CODE> attributes are
required.
<P>
Here's an example:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#set var=&quot;category&quot; value=&quot;help&quot; &#173;&#173;&gt;
</FONT>
</PRE>
<H1><A NAME="_Toc403834038">Conditional Inclusion</A></H1>
<P>
Ah, here's the section on the <I>really</I> neat things you can
do with server&#173;side includes. Using conditional inclusion,
you can tailor the actual contents of what gets sent to the client.
<P>
To do conditional inclusion, you surround portions of your text
with &quot;<CODE>#if</CODE>&quot; and &quot;<CODE>#endif</CODE>&quot;
SSI directives. (Think of them as a container if you like.) If
you want to handle alternatives, you can break the portion into
sub&#173;pieces with &quot;<CODE>#else</CODE>&quot; and &quot;<CODE>#elif</CODE>&quot;
directives.
<P>
The <CODE>#if</CODE> and <CODE>#elif</CODE> directives work the
same way. They take a look at the expression you give them, figure
out if it's true or not, and if it's true then the server will
include the enclosed bit of text in what it sends to the client.
If it's false, then the enclosed bit is ignored and not sent.
<P>
<I><B>Tip: </B></I>Like other server&#173;side include directives,
these are removed after they've been processed, so they shouldn't
show up in what gets transmitted to the client.
<P>
The syntax of an expression for <CODE>#if</CODE> and <CODE>#elif</CODE>
can get pretty complicated, but the basic format looks like this:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#if expr=&quot;<I>expression</I>&quot; &#173;&#173;&gt;
</FONT>
</PRE>
<P>
&quot;What's an expression,&quot; you ask? It's simply a thing
that can be tested to see if turns into an empty string (is false)
or not (is true). Based upon that, the first directive below would
be considered &quot;true,&quot; the second one would be treated
as &quot;false,&quot; and the third one would be &quot;true&quot;
if the variable &quot;<CODE>CONDITION</CODE>&quot; had a non&#173;empty
value and &quot;false&quot; if it didn't exist or was set to an
empty string:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#if expr=&quot;string&quot; &#173;&#173;&gt;
&lt;!&#173;&#173;#if expr=&quot;&quot; &#173;&#173;&gt;
&lt;!&#173;&#173;#if expr=&quot;$CONDITION&quot; &#173;&#173;&gt;
</FONT>
</PRE>
<P>
That's the simplest case. &quot;<I>Expression</I>&quot; can be
more complicated, such as:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#if expr=&quot;(<I>expression</I>)&quot; &#173;&#173;&gt;
&lt;!&#173;&#173;#if expr=&quot;!<I>expression</I>&quot; &#173;&#173;&gt;
&lt;!&#173;&#173;#if expr=&quot;<I>expression</I> &amp;&amp; <I>expression</I>&quot; &#173;&#173;&gt;
&lt;!&#173;&#173;#if expr=&quot;<I>expression</I> || <I>expression</I>&quot; &#173;&#173;&gt;
&lt;!&#173;&#173;#if expr=&quot;<I>string relop string</I>&quot; &#173;&#173;&gt;

</FONT>
</PRE>
<P>
&quot;What does &quot;<CODE>!<I><FONT SIZE=2 FACE="Courier New">expression</FONT></I></CODE>&quot;
mean,&quot; you say? The bang (a nickname for the exclamation
mark) means &quot;not,&quot; so it turns the meaning around. &quot;<CODE>!($V
= 23)</CODE>&quot; is true if the value of variable &quot;<CODE>V</CODE>&quot;
is anything except &quot;<CODE>23</CODE>&quot; &#173; even if
it doesn't exist at all.
<P>
&quot;What's a <CODE><I><FONT SIZE=2 FACE="Courier New">relop</FONT></I></CODE>?&quot;
you may ask. It's a <I>relational operator</I>, such as &quot;<CODE>=</CODE>&quot;
for &quot;is equal to,&quot; &quot;<CODE>!=</CODE>&quot; for &quot;is
not equal to,&quot; &quot;<CODE>&gt;</CODE>&quot; for &quot;is
greater than,&quot; and so on. Here's a complete list:
<PRE>
<FONT SIZE=2>* <I>string1</I> = <I>string2
string1</I> = /<I>pattern</I>/
</FONT>
</PRE>
<P>
The expression is true if the two strings are the same. If the
second string is enclosed in slashes, it's treated as a (case&#173;sensitive)
regular expression rather than a simple string. (&quot;Regular
expressions&quot; are a very powerful pattern&#173;matching mechanism
&#173; see the documentation for the operating system command
<CODE>grep</CODE> for more information about them.) The expression
is considered to be true if the string matches the pattern.
<P>
<I><B>Tip: </B></I>Comparisons in <CODE>#if</CODE> and <CODE>#elif</CODE>
directives <I>are</I> case&#173;sensitive! An expression such
as &quot;<CODE>A = a</CODE>&quot; will be <I>false</I> because
the strings aren't identical.
<PRE>
<FONT SIZE=2>* <I>string1</I> != </FONT><TT><I><FONT SIZE=2 FACE="Courier New">string2
string1</FONT></I></TT><FONT SIZE=2 FACE="Courier New"> != /</FONT><TT><I><FONT SIZE=2 FACE="Courier New">pattern</FONT></I></TT><FONT SIZE=2 FACE="Courier New">/
</FONT>
</PRE>
<P>
This is basically the same as the &quot;<CODE>=</CODE>&quot; relop,
except that the expression is true if the strings are <I>not</I>
the same or the string <I>doesn't</I> match the pattern.
<PRE>
<FONT SIZE=2>* <I>string1</I> &lt; <I>string2
string1</I> &lt;= <I>string2
string1</I> &gt; <I>string2
string1</I> &gt;= <I>string2
</I></FONT>
</PRE>
<P>
These are true if the relationship between the two strings is
as indicated (<I>e.g.</I>, &quot;<CODE>'1' &lt; '2'</CODE>&quot;
is true).
<P>
<I><B>Remember: </B></I>Don't forget that these comparisons are
done as <I>strings</I>, not as numbers. So &quot;<CODE>2</CODE>&quot;
is greater than &quot;<CODE>12</CODE>&quot; because the strings
are compared character&#173;by&#173;character, and &quot;<CODE>2</CODE>&quot;
is greater than &quot;<CODE>1</CODE>&quot;.
<P>
You can build up even more complicated expressions by joining
them with &quot;<CODE>&amp;&amp;</CODE>&quot; (which means both
must be true) and &quot;<CODE>||</CODE>&quot; which means either
one, the other, or both must be true). So if you want the word
&quot;Eureka!&quot; to be included in the response to the client
if <CODE>V1</CODE> is equal to &quot;<CODE>23</CODE>&quot; <I>and</I>
either <CODE>V2</CODE> equals &quot;<CODE>17</CODE>&quot; <I>or</I>
V2 equals &quot;<CODE>19</CODE>&quot;, here's what it would look
like:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#if expr=&quot;($V1 = 23) &amp;&amp; (($V2 = 17) || ($V2 = 19))&quot; &#173;&#173;&gt;
   Eureka!
&lt;!&#173;&#173;#endif &#173;&#173;&gt;
</FONT>
</PRE>
<P>
When the server has to evaluate a bunch of these operators, &quot;<CODE>!</CODE>&quot;
is done first, then &quot;<CODE>=</CODE>&quot; and &quot;<CODE>!=</CODE>&quot;,
then the other relops, and finally &quot;<CODE>&amp;&amp;</CODE>&quot;
and &quot;<CODE>||</CODE>&quot; are checked last. So the following
two expressions are equivalent:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#if expr=&quot;$a = test1 &amp;&amp; $b = test2&quot; &#173;&#173;&gt;
&lt;!&#173;&#173;#if expr=&quot;($a = test1) &amp;&amp; ($b = test2)&quot; &#173;&#173;&gt;
</FONT>
</PRE>
<P>
A simple conditional block is built like this:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#if expr=&quot;<I>condition</I>&quot; &#173;&#173;&gt; 
<I>   stuff to include or directives to process
</I>&lt;!&#173;&#173;#endif &#173;&#173;&gt;
</FONT>
</PRE>
<P>
One with a single alternative would look like this:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#if expr=&quot;<I>condition</I>&quot; &#173;&#173;&gt;<I> 
</I>  <I>stuff to include or directives to process
</I>&lt;!&#173;&#173;#else &#173;&#173;&gt;<I> 
  more stuff
</I>&lt;!&#173;&#173;#endif &#173;&#173;&gt;
</FONT>
</PRE>
<P>
And one with multiple alternatives can be constructed like so:
<PRE>
<FONT SIZE=2>&lt;!&#173;&#173;#if expr=&quot;<I>condition</I>&quot; &#173;&#173;&gt;<I> 
  stuff to include or directives to process
</I>&lt;!&#173;&#173;#elif expre=&quot;<I>another&#173;condition</I>&quot; &#173;&#173;&gt; 
<I>  other stuff
</I>&lt;!&#173;&#173;#else &#173;&#173;&gt;
<I>  more stuff
</I>&lt;!&#173;&#173;#endif &#173;&#173;&gt;
</FONT>
</PRE>
<P>
You can have as many <CODE>#elif</CODE> directives as you like
inside the <CODE>#if</CODE>&#173;<CODE>#endif</CODE> container,
but only zero or one #else (for the last alternative, if any).
And you can nest <CODE>#if</CODE>&#173;<CODE>#endif</CODE> containers
within each other for truly frightening control over your documents.
<P>
Great! Now you have all the theory, but what you can actually
<I>do</I> with all this stuff? Well, Figure C&#173;6 gives you
an example; going further is left as an exercise. Give yourself
20 Apache Guru Points for getting this far, and go forth and enjoy!
<HR>
<PRE>
<FONT SIZE=2>&lt;HTML&gt; 
 &lt;HEAD&gt; 
  &lt;!&#173;&#173;#if expr=&quot;$HTTP_USER_AGENT = /[Ll]ynx/&quot; &#173;&#173;&gt; 
   &lt;!&#173;&#173;#set var=&quot;SIMPLETEXT&quot; value=&quot;true&quot; &#173;&#173;&gt; 
  &lt;!&#173;&#173;#endif &#173;&#173;&gt; 
  &lt;TITLE&gt;Just a page with a 
  &lt;!&#173;&#173;#if expr=&quot;$SIMPLETEXT&quot; &#173;&#173;&gt; 
   sentence 
  &lt;!&#173;&#173;#else &#173;&#173;&gt; 
   picture 
  &lt;!&#173;&#173;#endif &#173;&#173;&gt; 
 &lt;/TITLE&gt; 
&lt;/HEAD&gt; 
 &lt;BODY&gt; 
  &lt;H1&gt;A Browser&#173;Sensitive Page&lt;/H1&gt; 
  &lt;!&#173;&#173;#if expr=&quot;$SIMPLETEXT&quot; &#173;&#173;&gt; 
  Your browser, &quot;&lt;!&#173;&#173;#echo var=&quot;HTTP_USER_AGENT&quot; &#173;&#173;&gt;&quot;, does 
  not appear to be able to display images &#173; so you get to 
  see this sentence instead. Sorry! 
  &lt;!&#173;&#173;#else &#173;&#173;&gt; 
  &lt;IMG SRC=&quot;absolutely&#173;breathtaking.gif&quot;&gt; 
  &lt;!&#173;&#173;#endif &#173;&#173;&gt; 
 &lt;/BODY&gt;
&lt;/HTML&gt;
</FONT>
</PRE>
<HR>

<PRE>
<CENTER><SAMP><FONT SIZE=1>Figure
</FONT></SAMP><FONT SIZE=1>C&#173;6





</FONT></CENTER>
</PRE>
</BODY>
</HTML>
